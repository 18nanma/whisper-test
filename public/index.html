<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- <script src="dummy.js" type='text/javascript' ></script> -->
    <!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script> -->
  
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="ScribeAR - an accessibility app by the University of Illinois Urbana-Champaign"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <script src="helpers.js" type="text/jsx"></script>
    <title>ScribeAR</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
   
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
            
    <div id="input" style='z-index: 100000;'>
      <button id="start"  onclick="onStart()" disabled style='z-index: 100000; margin-top: 20%;'>Start</button>
      <button id="stop"   onclick="onStop()" disabled style='z-index: 100000; margin-top: 20%;'>Stop</button>
      <button id="clear"  onclick="clearCache()" style='z-index: 100000; '>Clear Cache</button>
  </div>
  <button id="fetch-whisper-tiny-en" onclick="loadWhisper('tiny.en')" style='z-index: 10000; margin-top: 20%;'>tiny.en (75 MB)</button>
   

  <div id="root"></div>
  <script type='text/javascript'>
    // web audio context
    var context = null;

    // audio data
    var audio = null;
    var audio0 = null;

    // the stream instance
    var instance = null;

    // model name
    var model_whisper = null;

    var Module = {
        setStatus: function(text) {
          console.log('js: ' + text);
        },
        monitorRunDependencies: function(left) {
        },
        preRun: function() {
          console.log('js: Preparing ...');
        },
        postRun: function() {
          console.log('js: Initialized successfully!');
        }
    };

    //
    // fetch models
    //

    let dbVersion = 1
    let dbName    = 'whisper.ggerganov.com';
    let indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB

    function storeFS(fname, buf) {
        // write to WASM file using FS_createDataFile
        // if the file exists, delete it
        try {
            Module.FS_unlink(fname);
        } catch (e) {
            // ignore
        }

        Module.FS_createDataFile("/", fname, buf, true, true);

        console.log('storeFS: stored model: ' + fname + ' size: ' + buf.length);

        console.log('model-whisper-status' + ' loaded "' + model_whisper + '"!')

        if (model_whisper != null) {
            document.getElementById('start').disabled = false;
            document.getElementById('stop' ).disabled = true;
        }
    }

    function loadWhisper(model) {
      alert("clicked")
        let urls = {
            'tiny.en': 'https://angrave.web.engr.illinois.edu/scribear/data/ggml-model-whisper-tiny.en.bin',
            'base.en': 'https://whisper.ggerganov.com/ggml-model-whisper-base.en.bin',
        };

        let sizes = {
            'tiny.en': 75,
            'base.en': 142,
        };

        let url     = urls[model];
        let dst     = 'whisper.bin';
        let size_mb = sizes[model];

        model_whisper = model;

        document.getElementById('fetch-whisper-tiny-en').style.display = 'none';
        // document.getElementById('fetch-whisper-base-en').style.display = 'none';
        // document.getElementById('model-whisper-status').innerHTML = 'loading "' + model + '" ... ';

        cbProgress = function(p) {
          console.log(Math.round(100*p) + '%')
            // let el = document.getElementById('fetch-whisper-progress');
            // el.innerHTML = Math.round(100*p) + '%';
        };

        cbCancel = function() {
            var el;
            el = document.getElementById('fetch-whisper-tiny-en'); if (el) el.style.display = 'inline-block';
            // el = document.getElementById('fetch-whisper-base-en'); if (el) el.style.display = 'inline-block';
            // el = document.getElementById('model-whisper-status');  if (el) el.innerHTML = '';
        };

        window.loadRemote(url, dst, size_mb, cbProgress, storeFS, cbCancel, printTextarea);
    }

    //
    // microphone
    //

    const kSampleRate = 16000;
    const kRestartRecording_s = 120;
    const kIntervalAudio_ms = 3000; // pass the recorded audio to the C++ instance at this rate

    var mediaRecorder = null;
    var doRecording = false;
    var startTime = 0;

    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    window.OfflineAudioContext = window.OfflineAudioContext || window.webkitOfflineAudioContext;

    function stopRecording() {
        Module.set_status("paused");
        doRecording = false;
        audio0 = null;
        audio = null;
        context = null;
    }

    function startRecording() {
        if (!context) {
            context = new AudioContext({
                sampleRate: kSampleRate,
                channelCount: 1,
                echoCancellation: false,
                autoGainControl:  true,
                noiseSuppression: true,
            });
        }

        Module.set_status("");

        document.getElementById('start').disabled = true;
        document.getElementById('stop').disabled = false;

        doRecording = true;
        startTime = Date.now();

        var chunks = [];
        var stream = null;

        navigator.mediaDevices.getUserMedia({audio: true, video: false})
            .then(function(s) {
                stream = s;
                mediaRecorder = new MediaRecorder(stream);
                mediaRecorder.ondataavailable = function(e) {
                    chunks.push(e.data);

                    var blob = new Blob(chunks, { 'type' : 'audio/ogg; codecs=opus' });
                    var reader = new FileReader();

                    reader.onload = function(event) {
                        var buf = new Uint8Array(reader.result);

                        if (!context) {
                            return;
                        }
                        context.decodeAudioData(buf.buffer, function(audioBuffer) {
                            var offlineContext = new OfflineAudioContext(audioBuffer.numberOfChannels, audioBuffer.length, audioBuffer.sampleRate);
                            var source = offlineContext.createBufferSource();
                            source.buffer = audioBuffer;
                            source.connect(offlineContext.destination);
                            source.start(0);

                            offlineContext.startRendering().then(function(renderedBuffer) {
                                audio = renderedBuffer.getChannelData(0);

                                //printTextarea('js: audio recorded, size: ' + audio.length + ', old size: ' + (audio0 == null ? 0 : audio0.length));

                                var audioAll = new Float32Array(audio0 == null ? audio.length : audio0.length + audio.length);
                                if (audio0 != null) {
                                    audioAll.set(audio0, 0);
                                }
                                audioAll.set(audio, audio0 == null ? 0 : audio0.length);

                                if (instance) {
                                    Module.set_audio(instance, audioAll);
                                }
                            });
                        }, function(e) {
                            audio = null;
                        });
                    }

                    reader.readAsArrayBuffer(blob);
                };

                mediaRecorder.onstop = function(e) {
                    if (doRecording) {
                        setTimeout(function() {
                            startRecording();
                        });
                    }
                };

                mediaRecorder.start(kIntervalAudio_ms);
            })
            .catch(function(err) {
                console.log('js: error getting audio stream: ' + err);
            });

        var interval = setInterval(function() {
            if (!doRecording) {
                clearInterval(interval);
                mediaRecorder.stop();
                stream.getTracks().forEach(function(track) {
                    track.stop();
                });

                document.getElementById('start').disabled = false;
                document.getElementById('stop').disabled  = true;

                mediaRecorder = null;
            }

            // if audio length is more than kRestartRecording_s seconds, restart recording
            if (audio != null && audio.length > kSampleRate*kRestartRecording_s) {
                if (doRecording) {
                    //printTextarea('js: restarting recording');

                    clearInterval(interval);
                    audio0 = audio;
                    audio = null;
                    mediaRecorder.stop();
                    stream.getTracks().forEach(function(track) {
                        track.stop();
                    });
                }
            }
        }, 100);
    }

    //
    // main
    //

    var nLines = 0;
    var intervalUpdate = null;
    var transcribedAll = '';

    function onStart() {
        if (!instance) {
            instance = Module.init('whisper.bin');

            if (instance) {
                console.log("js: whisper initialized, instance: " + instance);
            }
        }

        if (!instance) {
            console.log("js: failed to initialize whisper");
            return;
        }

        startRecording();

        intervalUpdate = setInterval(function() {
            var transcribed = Module.get_transcribed();

            if (transcribed != null && transcribed.length > 1) {
                transcribedAll += transcribed + '<br>';
                nLines++;

                // if more than 10 lines, remove the first line
                if (nLines > 10) {
                    var i = transcribedAll.indexOf('<br>');
                    if (i > 0) {
                        transcribedAll = transcribedAll.substring(i + 4);
                        nLines--;
                    }
                }
            }

            // document.getElementById('state-status').innerHTML = Module.get_status();
            // document.getElementById('state-transcribed').innerHTML = transcribedAll;
        }, 100);
    }

    function onStop() {
        stopRecording();
    }

</script>

<!-- <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.3/jquery.min.js"></script>   -->
<script  src="stream.js" type="text/jsx"></script>
<script  src="libstream.worker.js" type="text/jsx"></script>

 
 
  </body>
</html>
